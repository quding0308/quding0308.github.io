---
layout: post
title:  "algorithm-复杂度分析"
# date:   2018-06-23 10:05:05 +0800
categories: blog algorithm
---

* 目录
{:toc}

### 为什么需要复杂度分析？

实际把代码跑一遍，通过统计算法的执行时间和内存占用大小来衡量，也可以评估算法的执行效率，但有一些局限性。

- 测试结果很依赖测试环境。不同设备测试结果会有很大不同
- 测试结果收数据规模影响很大。不同数据量级，算法的表现也不同

我们需要一个不用具体测试数据来测试，就可以粗略估计算法的执行效率的方法。

### 大 O 复杂度表示法

大O时间复杂度表示法 也叫渐进时间复杂度。并不表示代码的真正执行时间，而是表示**代码执行时间随数据规模增长的变化趋势**。

#### 大O记法：

> “大O记法”：对于单调的整数函数f，如果存在一个整数函数g和实常数c>0，使得对于充分大的n总有f(n)<=c*g(n)，就说函数g是f的一个渐近函数（忽略常数），记为f(n)=O(g(n))。也就是说，在趋向无穷的极限意义下，函数f的增长速度受到函数g的约束，亦即函数f与函数g的特征相似。时间复杂度：假设存在函数g，使得算法A处理规模为n的问题示例所用时间为T(n)=O(g(n))，则称O(g(n))为算法A的渐近时间复杂度，简称时间复杂度，记为T(n)

大O符号（英语：Big O notation），又称为渐进符号，是用于描述函数渐近行为的数学符号。它是用另一个（通常更简单的）函数来描述一个函数数量级的渐近上界。

举例

    T(n) = 4n^2 - 2n + 2
    当n足够大，2n 可以忽略，系数也可以忽略，剩下 n^2 占主导地位。
    
    T(n)的复杂度可以表示为：
    T(n) = O(n^2)

    我们就说 该算法具有 n^2阶（平方阶）的时间复杂度。

### 时间复杂度计算规则

- 基本操作，即只有常数项，认为其时间复杂度为O(1)
- 顺序结构，时间复杂度按加法进行计算
- 循环结构，时间复杂度按乘法进行计算
- 分支结构，时间复杂度取最大值

计算规则
- 只关注循环次数最多的一段代码
- 加法法则：总复杂度等于量级最大的那段代码的复杂度。假如 f(x) 是几项之和，那么只保留增长最快（通常是阶最高）的项，其他项省略
- 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积。
- 
- 假如 f(x) 是几项之积，那么常数（不取决于x的乘数）省略

举例1

    例如 f(x) = 6*x^4 + 3*x^3 + 5 

    根据规则1，忽略后两项，保留增长最快的项：6*x^4
    根据规则2，忽略系数6，最后的大O表示为：

    f(x） = O(x^4)

    读作：该算法具有 x^4 阶的时间复杂度

举例2
    
    冒泡排序

    void bubble_sort(int arr[], int len) {	
        int i, j;	
        for (i = 0; i < len - 1; i++) {
            for (j = 0; j < len - 1 - i; j++) {
                if (arr[j] > arr[j + 1]) {
                    swap(arr[j], arr[j + 1]);
                }
            }
        }
    }

    f(n) = n * (n) 


### 其他基本概念

假定计算机执行每一个操作的时间是固定的一个单位时间，那么有多少个基本操作就会花费多少个单位时间。

不同机器上，单位时间可能不同，但进行多少个操作在规模数量上是相同的，由此可以忽略机器环境的影响，而客观地反映算法的时间效率。

算法完成工作最少需要多少基本操作，即**最优时间复杂度**

算法完成工作最多需要多少基本操作，即**最坏时间复杂度**

算法完成工作平均需要多少基本操作，即**平均时间复杂度**


对于最坏时间复杂度，提供了一种保证，表明算法在此种程度的基本操作中一定能完成工作。

对于平均时间复杂度，是对算法的一个全面评价，因此它完整全面的反映了这个算法的性质。

我们主要关注算法的最坏情况，亦即最坏时间复杂度。

对于算法的时间性质和空间性质，最重要的是其数量级和趋势，这些是分析算法效率的主要部分。


### 几种常见复杂度
- 常量阶 O(1)
- 对数阶 O(log(n))
- 线性阶 O(n)
- 线性对数阶 O(n*log(n))
- 平方阶 O(n^2)
- 立方阶 O(n^3)
- k次方阶 O(n^k)
- 指数阶 O(2^n)
- 阶乘阶 O(n!)

其中， O(2^n) 和 O(n!) 是非多项式量级的算法。当 n 增大时，非多项式量级算法的时间会急剧增加，是非常低效的算法。

### 常见代码的复杂度分析

### 学习资源
https://www.jianshu.com/p/21428f9f4160

https://www.google.com/search?newwindow=1&safe=strict&ei=Ok-qW530MYv38QWI97zAAg&q=%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F+%E5%A4%8D%E6%9D%82%E5%BA%A6%E8%AE%A1%E7%AE%97&oq=%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F+%E5%A4%8D%E6%9D%82%E5%BA%A6%E8%AE%A1%E7%AE%97&gs_l=psy-ab.3...445249.448257.0.448525.13.11.0.0.0.0.283.1195.2-5.5.0....0...1c.1j4.64.psy-ab..8.4.956...0j0i12k1j0i30k1.0.ulmd_sXzoyo

https://zh.wikipedia.org/wiki/%E5%A4%A7O%E7%AC%A6%E5%8F%B7
