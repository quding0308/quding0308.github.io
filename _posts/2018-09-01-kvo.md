---
layout: post
title:  "KVO 原理"
categories: blog
---

* 目录
{:toc}


### KVO原理

#### 使用：

```
- (void)init {}
    [obj addObserver:self forKeyPath:@"obj_property_name" options:NSKeyValueChangeNewKey context:nil];
}
- (void)dealloc {
    [obj removeObserver:self forKeyPath:@"obj_property_name"];
}
- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary<NSKeyValueChangeKey,id> *)change context:(void *)context {
    //
}
```

#### 具体原理
1. kvo 基于runtime 实现
2. 当Person对象的某个 property 被观察后，会重新生成一个setter 在复制的前后调用 willChangeValueForKey: 和 didChangeValueForKey: ，从而 observeValueForKey:ofObject:change:context: 也会被调用
3. 实际Person对象，会生成一个Person的子类 NSKVONotifying_Person ，然后Person对象的isa指针指向 NSKVONotifying_Person。

NSKVONotifying_Person 的 set 重写为：

```
- (void)setName:(NSString *)name {
    [self willChangeValueForKey: @"name"];
    [super setName: name]; // 调用父类的setName，即使我们重写了setName 也会正常调用
    [self didChangeValueForKey: @"name"];
}
```


参考：https://zhuanlan.zhihu.com/p/34273366